# Logstash configuration for Project GENESIS

input {
  # Read GENESIS log files
  file {
    path => "/genesis/logs/trading.log"
    start_position => "beginning"
    codec => "json"
    type => "trading"
    tags => ["genesis", "trading"]
  }
  
  file {
    path => "/genesis/logs/audit.log"
    start_position => "beginning"
    codec => "json"
    type => "audit"
    tags => ["genesis", "audit", "security"]
  }
  
  file {
    path => "/genesis/logs/tilt.log"
    start_position => "beginning"
    codec => "json"
    type => "tilt"
    tags => ["genesis", "tilt", "behavior"]
  }
  
  # Receive logs via TCP (for remote logging)
  tcp {
    port => 5000
    codec => "json_lines"
    type => "remote"
    tags => ["genesis", "remote"]
  }
  
  # Receive logs via UDP (for high-performance logging)
  udp {
    port => 5001
    codec => "json"
    type => "performance"
    tags => ["genesis", "performance"]
  }
}

filter {
  # Parse timestamp
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss,SSS" ]
    target => "@timestamp"
  }
  
  # Add correlation ID if present
  if [correlation_id] {
    mutate {
      add_field => { "trace_id" => "%{correlation_id}" }
    }
  }
  
  # Parse log level
  if [level] {
    mutate {
      add_field => { "log_level" => "%{level}" }
    }
  }
  
  # Enrich trading logs
  if [type] == "trading" {
    # Parse order events
    if [event_type] == "ORDER_PLACED" or [event_type] == "ORDER_FILLED" {
      mutate {
        add_field => { 
          "order_id" => "%{[data][order_id]}"
          "symbol" => "%{[data][symbol]}"
          "side" => "%{[data][side]}"
          "price" => "%{[data][price]}"
          "quantity" => "%{[data][quantity]}"
        }
      }
    }
    
    # Parse position events
    if [event_type] == "POSITION_OPENED" or [event_type] == "POSITION_CLOSED" {
      mutate {
        add_field => {
          "position_id" => "%{[data][position_id]}"
          "pnl" => "%{[data][pnl]}"
        }
      }
    }
    
    # Calculate execution time
    if [start_time] and [end_time] {
      ruby {
        code => "
          start_time = event.get('start_time').to_f
          end_time = event.get('end_time').to_f
          event.set('execution_time_ms', (end_time - start_time) * 1000)
        "
      }
    }
  }
  
  # Enrich audit logs
  if [type] == "audit" {
    # Flag critical security events
    if [event_type] == "UNAUTHORIZED_ACCESS" or [event_type] == "PERMISSION_DENIED" {
      mutate {
        add_tag => ["security_alert"]
        add_field => { "alert_severity" => "critical" }
      }
    }
    
    # Track configuration changes
    if [event_type] == "CONFIG_CHANGE" {
      mutate {
        add_tag => ["config_change"]
        add_field => {
          "config_key" => "%{[data][key]}"
          "old_value" => "%{[data][old_value]}"
          "new_value" => "%{[data][new_value]}"
        }
      }
    }
  }
  
  # Enrich tilt logs
  if [type] == "tilt" {
    # Parse tilt score
    if [tilt_score] {
      mutate {
        convert => { "tilt_score" => "float" }
      }
      
      # Add severity based on score
      if [tilt_score] >= 90 {
        mutate {
          add_tag => ["tilt_critical"]
          add_field => { "tilt_severity" => "critical" }
        }
      } else if [tilt_score] >= 70 {
        mutate {
          add_tag => ["tilt_warning"]
          add_field => { "tilt_severity" => "warning" }
        }
      }
    }
    
    # Parse behavioral indicators
    if [indicators] {
      ruby {
        code => "
          indicators = event.get('indicators')
          if indicators.is_a?(Hash)
            indicators.each do |key, value|
              event.set(\"indicator_#{key}\", value)
            end
          end
        "
      }
    }
  }
  
  # Add tier information
  if [tier] {
    mutate {
      add_field => { "trading_tier" => "%{tier}" }
    }
  }
  
  # Parse error logs
  if [level] == "ERROR" or [level] == "CRITICAL" {
    mutate {
      add_tag => ["error"]
    }
    
    # Extract stack trace if present
    if [exception] {
      grok {
        match => { 
          "exception" => "%{GREEDYDATA:exception_message}\n%{GREEDYDATA:stack_trace}"
        }
        tag_on_failure => []
      }
    }
  }
  
  # Anonymize sensitive data
  mutate {
    # Remove API keys
    gsub => [
      "message", "api_key=['\"]?[^'\"\\s]+['\"]?", "api_key=REDACTED",
      "message", "secret=['\"]?[^'\"\\s]+['\"]?", "secret=REDACTED"
    ]
  }
  
  # Add environment metadata
  mutate {
    add_field => {
      "environment" => "${ENVIRONMENT:production}"
      "service" => "genesis"
      "version" => "${VERSION:1.0.0}"
    }
  }
  
  # Calculate metrics for performance analysis
  if [type] == "performance" {
    metrics {
      meter => ["events"]
      add_tag => ["metric"]
      flush_interval => 60
      rates => [1, 5, 15]
    }
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOST:elasticsearch:9200}"]
    index => "genesis-%{type}-%{+YYYY.MM.dd}"
    document_type => "_doc"
    template_name => "genesis"
    template => "/etc/logstash/templates/genesis-template.json"
    template_overwrite => true
    
    # Use document ID for deduplication
    document_id => "%{[@metadata][fingerprint]}"
  }
  
  # Send critical alerts to monitoring
  if "security_alert" in [tags] or "tilt_critical" in [tags] {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      format => "json"
      mapping => {
        "labels" => {
          "alertname" => "%{event_type}"
          "severity" => "%{alert_severity}"
          "service" => "genesis"
        }
        "annotations" => {
          "description" => "%{message}"
          "timestamp" => "%{@timestamp}"
        }
      }
    }
  }
  
  # Archive raw logs to S3 for compliance
  s3 {
    region => "${AWS_REGION:us-east-1}"
    bucket => "${S3_BUCKET:genesis-logs}"
    prefix => "raw/%{type}/%{+YYYY/MM/dd}/"
    time_file => 300
    codec => "json_lines"
    canned_acl => "private"
    server_side_encryption => true
    storage_class => "STANDARD_IA"
  }
  
  # Debug output (disable in production)
  if "${DEBUG_MODE:false}" == "true" {
    stdout {
      codec => rubydebug
    }
  }
}