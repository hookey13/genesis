# Story 10.5: Trading Engine Integration & Orchestration

## Status
Approved

## Story
**As a** system architect,
**I want** to connect all trading components into a cohesive live trading loop,
**So that** strategies can execute trades in real-time with proper orchestration and state management.

**Epic:** Epic 10 - Core Trading Brain Implementation
**Type:** Sequential-Required (Cannot be split - core integration)
**Branch:** feature/10-5
**Estimated Hours:** 16
**Developer Assignment:** Lead Integration Developer

## Acceptance Criteria
1. Main trading loop initialization in `__main__.py`
2. Strategy loading based on current tier
3. Real-time market data feed integration
4. Signal generation and validation pipeline
5. Order execution with proper error handling
6. Position tracking and P&L calculation
7. State persistence and recovery
8. Graceful shutdown procedures
9. Health monitoring and alerting
10. Performance metrics collection

## Tasks / Subtasks

- [ ] Initialize main trading loop (AC: 1)
  - [ ] Update __main__.py entry point with trading engine initialization
  - [ ] Add signal handlers for graceful shutdown
  - [ ] Configure logging for trading operations
- [ ] Implement strategy loading system (AC: 2)
  - [ ] Create StrategyRegistry class
  - [ ] Implement tier-based strategy loading
  - [ ] Add strategy validation and initialization
- [ ] Set up market data feed integration (AC: 3)
  - [ ] Create MarketDataFeed class
  - [ ] Integrate with WebSocket manager
  - [ ] Implement data validation and caching
- [ ] Build signal generation pipeline (AC: 4)
  - [ ] Create signal validation logic
  - [ ] Implement confidence scoring
  - [ ] Add signal routing to risk engine
- [ ] Implement order execution flow (AC: 5)
  - [ ] Create execution pipeline with error handling
  - [ ] Add retry logic with exponential backoff
  - [ ] Implement order status tracking
- [ ] Add position tracking system (AC: 6)
  - [ ] Create position manager
  - [ ] Implement P&L calculation
  - [ ] Add real-time position updates
- [ ] Implement state persistence (AC: 7)
  - [ ] Create state serialization logic
  - [ ] Implement recovery procedures
  - [ ] Add checkpoint system
- [ ] Build graceful shutdown procedures (AC: 8)
  - [ ] Implement safe position closing
  - [ ] Add state saving on shutdown
  - [ ] Create cleanup procedures
- [ ] Create health monitoring system (AC: 9)
  - [ ] Implement HealthMonitor class
  - [ ] Add component health checks
  - [ ] Create alerting mechanisms
- [ ] Add performance metrics collection (AC: 10)
  - [ ] Implement metrics collectors
  - [ ] Add latency tracking
  - [ ] Create performance reporting

## Dev Notes

### Testing Standards

**Test File Locations:**
- Unit tests: `tests/unit/test_*.py`
- Integration tests: `tests/integration/test_*.py`
- Test naming: `test_<module>_<functionality>`

**Testing Framework:**
- Framework: pytest 8.0.0
- Coverage tool: pytest-cov 4.1.0
- Async testing: pytest-asyncio
- Required coverage: >95% for critical paths

**Testing Requirements:**
- All async functions must be tested with pytest-asyncio
- Mock external dependencies (exchange APIs, market data)
- Test error paths and edge cases
- Validate state transitions
- Performance tests must meet latency requirements (<100ms)

### Relevant Source Tree

```plaintext
genesis/
├── __main__.py                    # Main entry point - update lines 218-250
├── engine/
│   ├── __init__.py
│   ├── engine.py                 # TradingEngine class - complete implementation
│   ├── event_bus.py              # Existing event system
│   ├── state_machine.py          # Existing state management
│   ├── risk_engine.py            # Existing risk validation
│   ├── orchestrator.py           # NEW - orchestration logic
│   ├── health_monitor.py         # NEW - health monitoring
│   └── strategy_registry.py      # NEW - strategy management
├── data/
│   ├── __init__.py
│   └── market_feed.py            # NEW - market data integration
├── exchange/
│   ├── gateway.py                # Existing - Binance API wrapper
│   └── websocket_manager.py      # Existing - WebSocket connections
├── strategies/
│   ├── loader.py                 # Existing - dynamic loading
│   └── base.py                   # Existing - BaseStrategy class
└── tilt/
    └── detector.py               # Existing - behavioral monitoring
```

### Architecture Context

**Technology Stack (from architecture docs):**
- Python 3.11.8 with asyncio for concurrent operations
- SQLite for MVP state persistence (upgrade to PostgreSQL at $2k+)
- structlog for structured logging
- decimal library for financial calculations
- In-memory caching with Python dicts and asyncio.Queue

**Performance Requirements:**
- Trading loop execution: <100ms per cycle
- Market data processing: <5ms per message
- Signal generation: <10ms per strategy
- Order execution latency: <50ms
- State persistence: checkpoint every 60 seconds

**Integration Points:**
- `genesis/exchange/gateway.py` - Market data and order execution
- `genesis/engine/risk_engine.py` - Signal validation
- `genesis/engine/state_machine.py` - Tier state management
- `genesis/strategies/loader.py` - Dynamic strategy loading
- `genesis/tilt/detector.py` - Behavioral monitoring integration

**Error Handling Requirements:**
- Circuit breaker pattern for exchange failures
- Exponential backoff for retries (initial: 100ms, max: 30s)
- Graceful degradation when components fail
- State recovery from last checkpoint
- Emergency stop with position liquidation

### Code Patterns to Follow

**Async/Await Pattern:**
```python
async def process_market_data(self, data: Dict[str, Any]) -> None:
    """Process incoming market data asynchronously."""
    try:
        validated_data = await self.validate_data(data)
        await self.update_cache(validated_data)
        await self.notify_strategies(validated_data)
    except ValidationError as e:
        logger.warning("data_validation_failed", error=str(e))
    except Exception as e:
        logger.error("market_data_processing_error", error=str(e))
        await self.circuit_breaker.record_failure()
```

**State Machine Integration:**
```python
@requires_state(EngineState.RUNNING)
async def execute_trade(self, signal: Signal) -> Order:
    """Execute trade with state validation."""
    # Implementation
```

**Structured Logging:**
```python
logger.info(
    "trade_executed",
    strategy=strategy_name,
    symbol=symbol,
    side=side,
    quantity=quantity,
    price=price,
    latency_ms=latency
)
```

### Files to Modify/Create
```
├── genesis/
│   ├── __main__.py [MODIFY - lines 218-250]
│   ├── engine/
│   │   ├── engine.py [MODIFY - complete implementation]
│   │   ├── orchestrator.py [CREATE]
│   │   ├── health_monitor.py [CREATE]
│   │   └── strategy_registry.py [CREATE]
│   └── data/
│       └── market_feed.py [CREATE]
└── tests/
    └── integration/
        └── test_trading_engine.py [CREATE]
```

### Code Modules Owned
- **Primary:** Trading engine core and orchestration
- **Secondary:** Strategy registry and health monitoring
- **No Touch:** Individual strategy implementations (other devs)

### Dependencies Context

**Must Complete Before Starting
- Story 10.1 (Market Analysis Engine)
- Story 10.2 (Sniper Strategies)
- Story 10.3 (Hunter Strategies)
- Story 10.4 (Strategist Algorithms)

### Can Start But Needs Later
- None (this is the integration point)

### Parallel Stories (Same Time)
- None (this requires all strategy components)

## Validation & Testing

### Testing Requirements

**Unit Tests Required:**
- `test_trading_engine.py` - Core engine functionality
- `test_strategy_registry.py` - Strategy loading and management
- `test_health_monitor.py` - Health monitoring system
- `test_orchestrator.py` - Orchestration logic
- `test_market_feed.py` - Market data processing

**Integration Tests Required:**
- Full trading loop with mock strategies
- Market data feed processing
- Signal generation and execution
- Error recovery scenarios
- Shutdown procedures

**Performance Tests:**
- Loop execution <100ms
- 100+ strategies concurrent
- Memory stability over 24h

### Validation Steps

1. Verify all acceptance criteria are met
2. Run unit tests with >95% coverage
3. Execute integration tests
4. Validate performance benchmarks
5. Test error recovery scenarios
6. Verify graceful shutdown
7. Check state persistence and recovery
8. Monitor memory usage over time
9. Validate with all strategy types
10. Peer review from all strategy developers

## Implementation Checklist
- [ ] Create feature branch via worktree
- [ ] Update __main__.py entry point
- [ ] Create StrategyRegistry class
- [ ] Implement TradingEngine core loop
- [ ] Add market data feed integration
- [ ] Create signal validation pipeline
- [ ] Implement order execution flow
- [ ] Add position tracking system
- [ ] Create state persistence
- [ ] Implement graceful shutdown
- [ ] Add HealthMonitor class
- [ ] Create performance collectors
- [ ] Write integration tests
- [ ] Test with all strategy types
- [ ] Validate error handling
- [ ] Create pull request
- [ ] Peer review from all strategy developers
- [ ] Merge to main branch

## Worktree Setup Commands
```bash
# Lead Integration Developer executes:
cd /path/to/main/repo
git worktree add -b feature/10-5 ../worktree-10-5
cd ../worktree-10-5

# After completion:
git push origin feature/10-5
# Create PR for review
```

## Definition of Done
- [ ] All acceptance criteria met
- [ ] Code review approved by all teams
- [ ] All tests passing
- [ ] Integration with all strategies verified
- [ ] Performance benchmarks met
- [ ] Documentation updated
- [ ] Branch merged to main

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-03 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-09-03 | 1.1 | Enhanced with full Dev Notes and validation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes List
_TBD_

### File List
_TBD_

## QA Results
_TBD_