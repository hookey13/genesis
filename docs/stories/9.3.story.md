# Story 9.3: HashiCorp Vault Integration for Secrets Management

## Story Information
**Epic:** 9 - Critical Security & Infrastructure Hardening  
**Story ID:** 9.3  
**Priority:** Critical (P0)  
**Estimated Effort:** 8 hours  
**Dependencies:** Story 9.2 (PostgreSQL for dynamic credentials)  
**Sub-Stories:** 9.3.1, 9.3.2  

## User Story
As a security engineer,  
I want to integrate HashiCorp Vault for all secret management,  
So that API keys and sensitive data are never exposed in code or environment variables.

## Problem Statement
The current system has hardcoded API keys, database passwords, and other secrets directly in source code or configuration files. This creates massive security vulnerabilities where anyone with code access can compromise the entire system. Additionally, there's no secret rotation, audit logging of secret access, or proper encryption of sensitive data. For a system handling $100k+ in capital, enterprise-grade secret management is mandatory to prevent credential theft and maintain compliance.

## Acceptance Criteria
1. HashiCorp Vault deployment with auto-unseal
2. Dynamic secret generation for database credentials
3. API key encryption with envelope encryption
4. Secret rotation without service interruption
5. Audit logging for all secret access
6. Emergency break-glass procedures
7. Local development secrets with different vault
8. CI/CD integration for secret injection
9. Kubernetes secret operator integration ready
10. Compliance with CIS Vault Benchmark

## Technical Implementation Details

### Core Components
```python
# New files to create:
# genesis/security/vault_manager.py - Main Vault integration
# genesis/security/credential_manager.py - Dynamic credential management
# genesis/security/secret_rotation.py - Automated secret rotation
# genesis/security/envelope_encryption.py - Envelope encryption utilities
# genesis/config/vault_config.py - Vault configuration management
```

### Vault Architecture
```yaml
# docker-compose.vault.yml
version: '3.8'
services:
  vault:
    image: vault:1.15
    container_name: genesis-vault
    ports:
      - "8200:8200"
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: genesis-dev-token
      VAULT_DEV_LISTEN_ADDRESS: 0.0.0.0:8200
    cap_add:
      - IPC_LOCK
    volumes:
      - ./vault/config:/vault/config:ro
      - ./vault/data:/vault/data
      - ./vault/logs:/vault/logs
    command: |
      vault server -config=/vault/config/vault.hcl

  vault-init:
    image: vault:1.15
    depends_on:
      - vault
    environment:
      VAULT_ADDR: http://vault:8200
    volumes:
      - ./vault/scripts:/scripts
    command: /scripts/init-vault.sh
```

### Files to Modify
- `genesis/config/settings.py` - Remove hardcoded secrets
- `genesis/database/connection.py` - Use dynamic database credentials
- `genesis/api/exchange_clients.py` - Use Vault for API keys
- `genesis/security/encryption.py` - Integrate envelope encryption
- `requirements.txt` - Add hvac (Vault client)
- `docker-compose.yml` - Add Vault service

### Vault Configuration
```hcl
# vault/config/vault.hcl
ui = true
cluster_name = "genesis-vault"

listener "tcp" {
  address = "0.0.0.0:8200"
  tls_disable = 1  # Only for development
}

storage "file" {
  path = "/vault/data"
}

# Auto-unseal with AWS KMS (production)
seal "awskms" {
  region = "us-east-1"
  kms_key_id = "genesis-vault-unseal-key"
}

# Enable audit logging
audit "file" {
  file_path = "/vault/logs/audit.log"
}

# API rate limiting
api_rate_limit {
  enable = true
  rate = 1000
  burst = 2000
}
```

### Secret Engine Configuration
```bash
# Initialize secret engines
vault secrets enable -path=genesis-secrets kv-v2
vault secrets enable -path=genesis-transit transit
vault secrets enable -path=genesis-database database

# Configure database secret engine
vault write genesis-database/config/postgresql \
  plugin_name=postgresql-database-plugin \
  connection_url="postgresql://{{username}}:{{password}}@postgres:5432/genesis_trading?sslmode=disable" \
  allowed_roles="genesis-app,genesis-readonly"

# Create database roles
vault write genesis-database/roles/genesis-app \
  db_name=postgresql \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}' IN ROLE genesis_app;" \
  default_ttl="1h" \
  max_ttl="24h"
```

## Implementation Checklist

### Phase 1: Vault Deployment & Setup (2 hours)
- [ ] Deploy HashiCorp Vault with Docker/Kubernetes
- [ ] Configure auto-unseal with cloud KMS
- [ ] Initialize vault with root tokens and recovery keys
- [ ] Enable audit logging for compliance
- [ ] Setup health monitoring and backup procedures
- [ ] Configure vault policies for least privilege access

### Phase 2: Secret Engine Configuration (2 hours)
- [ ] Enable KV-V2 secret engine for static secrets
- [ ] Configure Transit engine for encryption operations
- [ ] Setup Database engine for dynamic PostgreSQL credentials
- [ ] Create Vault policies for different access levels
- [ ] Configure secret TTL and rotation policies
- [ ] Test secret engines with sample data

### Phase 3: Application Integration (3 hours)
- [ ] Implement VaultManager class for secret operations
- [ ] Create credential manager for dynamic database access
- [ ] Integrate envelope encryption for sensitive data
- [ ] Update all hardcoded secrets to use Vault
- [ ] Implement secret caching with appropriate TTL
- [ ] Add Vault authentication and token renewal

### Phase 4: Secret Migration & Rotation (1 hour)
- [ ] Migrate existing secrets to Vault securely
- [ ] Implement automated secret rotation
- [ ] Setup break-glass emergency access procedures
- [ ] Configure CI/CD secret injection
- [ ] Test complete secret lifecycle management
- [ ] Validate compliance with security policies

## Testing Requirements

### Unit Tests
- [ ] Vault client connection and authentication
- [ ] Secret retrieval with proper error handling
- [ ] Envelope encryption/decryption operations
- [ ] Dynamic credential generation and cleanup
- [ ] Secret caching behavior and TTL
- [ ] Token renewal and authentication recovery

### Integration Tests
- [ ] Complete secret lifecycle (create, read, rotate, delete)
- [ ] Database connection with dynamic credentials
- [ ] Exchange API authentication with Vault keys
- [ ] Secret rotation without service interruption
- [ ] Vault failure recovery procedures
- [ ] Cross-service secret sharing validation

### Security Tests
- [ ] Unauthorized secret access prevention
- [ ] Token privilege escalation prevention
- [ ] Audit logging completeness verification
- [ ] Break-glass procedure validation
- [ ] Secret leakage prevention in logs/memory
- [ ] Vault seal/unseal security validation

### Performance Tests
- [ ] Secret retrieval latency under load
- [ ] Concurrent secret access performance
- [ ] Vault caching effectiveness
- [ ] Database credential rotation impact
- [ ] Large secret handling performance
- [ ] Network partition resilience

## Dependencies
- **Requires:** Story 9.2 (PostgreSQL for dynamic credentials)
- **Blocks:** All stories requiring secure credential management
- **External:** HashiCorp Vault, Cloud KMS for auto-unseal
- **Internal:** Secret migration coordination

## Definition of Done
- [ ] HashiCorp Vault deployed with auto-unseal capability
- [ ] All hardcoded secrets removed from codebase
- [ ] Dynamic database credentials operational
- [ ] API keys encrypted with envelope encryption
- [ ] Secret rotation working without service interruption
- [ ] Comprehensive audit logging for all secret access
- [ ] Break-glass emergency procedures documented and tested
- [ ] CI/CD secret injection functional
- [ ] Vault security policies enforcing least privilege
- [ ] Performance meets <10ms secret retrieval requirement
- [ ] Backup and disaster recovery for Vault data
- [ ] Compliance validation with security checklist

## Risk Mitigation
- **Vault Unavailability:** Implement graceful degradation and caching
- **Secret Migration Risk:** Gradual migration with rollback capability
- **Performance Impact:** Optimize caching and connection pooling
- **Security Regression:** Comprehensive audit of secret removal
- **Key Loss:** Multiple recovery mechanisms and backup procedures

## Success Metrics
- Zero hardcoded secrets remaining in codebase
- 100% secret access covered by audit logging
- <10ms average secret retrieval latency
- 99.9% Vault availability with monitoring
- Zero unauthorized secret access incidents
- 100% successful secret rotation operations

## Vault Security Policies

### Application Access Policy
```hcl
# genesis-app policy
path "genesis-secrets/data/app/*" {
  capabilities = ["read"]
}

path "genesis-database/creds/genesis-app" {
  capabilities = ["read"]
}

path "genesis-transit/encrypt/genesis-key" {
  capabilities = ["update"]
}

path "genesis-transit/decrypt/genesis-key" {
  capabilities = ["update"]
}
```

### Admin Access Policy
```hcl
# genesis-admin policy
path "genesis-secrets/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

path "genesis-database/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

path "sys/health" {
  capabilities = ["read", "sudo"]
}
```

### Break-Glass Emergency Policy
```hcl
# genesis-emergency policy
path "*" {
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}
```

## Secret Categories

### Static Secrets (KV-V2)
- Exchange API keys and secrets
- JWT signing keys
- Encryption master keys
- Third-party service credentials
- SSL/TLS certificates

### Dynamic Secrets (Database)
- PostgreSQL application credentials
- Read-only analytics credentials
- Backup service credentials
- Monitoring service credentials

### Transit Encryption
- API key envelope encryption
- Sensitive configuration data
- User PII encryption
- Trading signal encryption

## Notes
This is a **CRITICAL SECURITY** story that eliminates the massive vulnerability of hardcoded secrets. The current practice of embedding credentials in source code is completely unacceptable for any production system, especially one handling financial assets.

Vault provides enterprise-grade secret management with:
- Centralized secret storage with encryption at rest
- Dynamic credential generation with automatic rotation
- Detailed audit logging for compliance
- Fine-grained access control with policies
- High availability and disaster recovery
- Integration with cloud identity providers
- Zero-trust security model

The implementation must be done carefully to avoid service disruption during secret migration. All secrets must be validated before removing hardcoded versions.

Priority within story:
1. Vault deployment and configuration (foundation)
2. Dynamic database credentials (eliminates hardcoded DB passwords)
3. API key encryption (secures exchange credentials)
4. Secret rotation automation (ongoing security maintenance)