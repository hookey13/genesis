# Story 10.6.2: Performance Metrics & Analysis

## Status
Approved

## Story
**As a** quant researcher,
**I want** comprehensive performance metrics calculation for backtesting and live trading,
**So that** strategies can be evaluated using industry-standard risk-adjusted return metrics.

**Epic:** Epic 10 - Core Trading Brain Implementation
**Type:** Parallel-Safe
**Branch:** feature/10-6-2
**Estimated Hours:** 6
**Developer Assignment:** Developer 4

## Acceptance Criteria
1. PerformanceCalculator class implementation
2. Sharpe ratio calculation
3. Sortino ratio (downside deviation)
4. Calmar ratio (return/max drawdown)
5. Maximum drawdown tracking
6. Win rate and profit factor
7. Average trade statistics
8. Risk-adjusted returns
9. Rolling performance windows
10. Benchmark comparison tools

## Tasks / Subtasks

- [ ] Create PerformanceCalculator class (AC: 1)
  - [ ] Define metric interfaces
  - [ ] Implement base calculation framework
  - [ ] Add caching for expensive calculations
- [ ] Implement Sharpe ratio calculation (AC: 2)
  - [ ] Calculate returns standard deviation
  - [ ] Handle different time periods (daily, monthly, annual)
  - [ ] Add risk-free rate parameter
- [ ] Add Sortino ratio calculation (AC: 3)
  - [ ] Calculate downside deviation
  - [ ] Implement MAR (Minimum Acceptable Return)
  - [ ] Handle zero downside cases
- [ ] Create Calmar ratio calculation (AC: 4)
  - [ ] Link to maximum drawdown
  - [ ] Calculate annualized returns
  - [ ] Handle recovery periods
- [ ] Implement drawdown tracking (AC: 5)
  - [ ] Track running maximum
  - [ ] Calculate drawdown percentage
  - [ ] Record drawdown duration
- [ ] Add win rate and profit factor (AC: 6)
  - [ ] Count winning/losing trades
  - [ ] Calculate gross profit/loss
  - [ ] Handle edge cases (no losses)
- [ ] Calculate trade statistics (AC: 7)
  - [ ] Average win/loss amounts
  - [ ] Average trade duration
  - [ ] Maximum consecutive wins/losses
- [ ] Implement risk-adjusted returns (AC: 8)
  - [ ] Calculate risk-adjusted performance
  - [ ] Add volatility scaling
  - [ ] Implement information ratio
- [ ] Add rolling window analysis (AC: 9)
  - [ ] Create rolling metric calculations
  - [ ] Implement efficient windowing
  - [ ] Add time-based and count-based windows
- [ ] Build benchmark comparison tools (AC: 10)
  - [ ] Load benchmark data
  - [ ] Calculate relative performance
  - [ ] Add correlation analysis

## Dev Notes

### Testing Standards

**Test File Locations:**
- Unit tests: `tests/unit/test_performance_metrics.py`
- Report tests: `tests/unit/test_report_generator.py`
- Integration tests: `tests/integration/test_metrics_integration.py`

**Testing Framework:**
- Framework: pytest 8.0.0
- Coverage requirement: >90% for metrics module
- Precision: Use Decimal for financial calculations
- Validation: Compare against known formulas

### Relevant Source Tree

```plaintext
genesis/
├── backtesting/
│   ├── __init__.py
│   ├── engine.py              # Interface from 10.6.1
│   ├── portfolio.py           # Portfolio from 10.6.1
│   ├── performance_metrics.py # NEW - metrics calculations
│   └── report_generator.py    # NEW - report generation
├── monitoring/
│   ├── __init__.py
│   └── performance_attribution.py # NEW - attribution analysis
├── core/
│   └── models.py              # Trade, Position models
└── analytics/
    └── __init__.py             # Shared analytics
```

### Architecture Context

**Technology Stack:**
- Python 3.11.8 with type hints
- numpy 1.26.3 for statistical calculations
- pandas 2.2.0 for time series analysis
- decimal for precise financial math
- matplotlib/plotly for visualization

**Performance Requirements:**
- Calculate all metrics in <100ms for 1000 trades
- Support streaming calculation updates
- Memory efficient for large datasets
- Cache expensive calculations
- Thread-safe for concurrent access

**Metric Formulas:**

```python
# Sharpe Ratio
sharpe = (mean_return - risk_free_rate) / std_deviation

# Sortino Ratio
downside_returns = returns[returns < MAR]
downside_deviation = sqrt(mean(downside_returns ** 2))
sortino = (mean_return - MAR) / downside_deviation

# Calmar Ratio
calmar = annualized_return / abs(max_drawdown)

# Profit Factor
profit_factor = gross_profit / abs(gross_loss)

# Win Rate
win_rate = winning_trades / total_trades

# Maximum Drawdown
drawdown = (peak - trough) / peak * 100
```

**Data Structures:**

```python
@dataclass
class PerformanceMetrics:
    # Returns
    total_return: Decimal
    annualized_return: float
    
    # Risk metrics
    volatility: float
    max_drawdown: Decimal
    max_drawdown_duration: timedelta
    
    # Risk-adjusted returns
    sharpe_ratio: float
    sortino_ratio: float
    calmar_ratio: float
    information_ratio: float
    
    # Trade statistics
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    profit_factor: float
    avg_win: Decimal
    avg_loss: Decimal
    largest_win: Decimal
    largest_loss: Decimal
    avg_trade_duration: timedelta
    
    # Streak statistics
    max_consecutive_wins: int
    max_consecutive_losses: int
    current_streak: int
    
    # Period metrics
    best_day: Decimal
    worst_day: Decimal
    best_month: Decimal
    worst_month: Decimal
```

**Integration Points:**
- `genesis/backtesting/engine.py` - Receives portfolio data
- `genesis/backtesting/portfolio.py` - Trade and position data
- `genesis/monitoring/strategy_monitor.py` - Live performance tracking
- `genesis/ui/widgets/performance_widget.py` - Display metrics

**Calculation Patterns:**

```python
class PerformanceCalculator:
    def __init__(self, risk_free_rate: float = 0.02):
        self.risk_free_rate = risk_free_rate
        self._cache = {}
        
    def calculate_metrics(
        self,
        portfolio: Portfolio,
        benchmark: Optional[List[float]] = None
    ) -> PerformanceMetrics:
        """Calculate all performance metrics."""
        # Get returns series
        returns = self._calculate_returns(portfolio)
        
        # Calculate base metrics
        metrics = PerformanceMetrics(
            total_return=self._total_return(portfolio),
            annualized_return=self._annualized_return(returns),
            volatility=self._volatility(returns),
            max_drawdown=self._max_drawdown(portfolio),
            max_drawdown_duration=self._drawdown_duration(portfolio),
            sharpe_ratio=self._sharpe_ratio(returns),
            sortino_ratio=self._sortino_ratio(returns),
            calmar_ratio=self._calmar_ratio(returns, portfolio),
            # ... other metrics
        )
        
        # Add benchmark comparison if provided
        if benchmark:
            metrics.beta = self._calculate_beta(returns, benchmark)
            metrics.alpha = self._calculate_alpha(returns, benchmark)
            metrics.correlation = self._correlation(returns, benchmark)
        
        return metrics
    
    @lru_cache(maxsize=128)
    def _sharpe_ratio(
        self,
        returns: np.ndarray,
        periods_per_year: int = 252
    ) -> float:
        """Calculate Sharpe ratio with caching."""
        if len(returns) == 0:
            return 0.0
        
        mean_return = np.mean(returns)
        std_return = np.std(returns)
        
        if std_return == 0:
            return 0.0
        
        # Annualize
        annual_return = mean_return * periods_per_year
        annual_std = std_return * np.sqrt(periods_per_year)
        
        return (annual_return - self.risk_free_rate) / annual_std
```

**Report Generation:**

```python
class BacktestReportGenerator:
    def generate(
        self,
        metrics: PerformanceMetrics,
        portfolio: Portfolio,
        strategy: str
    ) -> str:
        """Generate HTML report with charts."""
        # Create report sections
        summary = self._create_summary(metrics)
        charts = self._create_charts(portfolio)
        trade_log = self._create_trade_log(portfolio.trades)
        
        # Combine into HTML
        return self._render_html(
            summary=summary,
            charts=charts,
            trade_log=trade_log,
            strategy=strategy
        )
```

### Files to Modify/Create
```
├── genesis/
│   ├── backtesting/
│   │   ├── performance_metrics.py [CREATE]
│   │   └── report_generator.py [CREATE]
│   └── monitoring/
│       └── performance_attribution.py [CREATE]
└── tests/
    └── unit/
        ├── test_performance_metrics.py [CREATE]
        └── test_report_generator.py [CREATE]
```

### Code Modules Owned
- **Primary:** `genesis/backtesting/performance_metrics.py`
- **Secondary:** `genesis/backtesting/report_generator.py`
- **Tertiary:** `genesis/monitoring/performance_attribution.py`
- **No Touch:** engine.py (Dev 3), strategies

### Dependencies Context

**Must Complete Before Starting
- None

### Can Start But Needs Later
- Story 10.6.1 (Backtest engine integration)
- Story 10.7 (Live monitoring integration)

### Parallel Stories (Same Time)
- Story 10.6.1 (Backtest Engine - Developer 3)
- Story 10.4.2 (Market Maker - Different team)
- Story 10.10.2 (Production Validation - Different team)

## Validation & Testing

### Testing Requirements

**Unit Tests Required:**
- `test_performance_metrics.py` - All metric calculations
- `test_report_generator.py` - Report generation
- `test_rolling_windows.py` - Rolling calculations
- `test_benchmark_comparison.py` - Benchmark tools
- `test_edge_cases.py` - Zero trades, all losses, etc.

**Validation Tests:**
- Compare Sharpe ratio with manual calculation
- Validate Sortino with known examples
- Check drawdown against historical data
- Verify profit factor calculation
- Cross-validate with QuantLib/zipline

**Performance Tests:**
- 1000 trades calculated in <100ms
- Rolling windows update in <10ms
- Report generation in <1 second
- Memory usage <100MB for 10k trades

### Validation Steps

1. Test with known portfolio data
2. Validate each metric formula
3. Check edge cases handling
4. Verify rolling window accuracy
5. Test benchmark comparisons
6. Validate report generation
7. Check calculation precision
8. Test with live data
9. Compare with external tools
10. Performance benchmark tests

## Implementation Checklist
- [ ] Create feature branch via worktree
- [ ] Create PerformanceCalculator class
- [ ] Implement Sharpe ratio calculation
- [ ] Add Sortino ratio
- [ ] Create Calmar ratio
- [ ] Implement drawdown tracking
- [ ] Add win rate calculations
- [ ] Create profit factor metric
- [ ] Implement rolling windows
- [ ] Add benchmark comparison
- [ ] Create report generator
- [ ] Add performance attribution
- [ ] Write unit tests for all metrics
- [ ] Validate calculations
- [ ] Create pull request
- [ ] Peer review from Story 10.6.1 developer
- [ ] Merge to main branch

## Worktree Setup Commands
```bash
# Developer 4 executes:
cd /path/to/main/repo
git worktree add -b feature/10-6-2 ../worktree-10-6-2
cd ../worktree-10-6-2

# After completion:
git push origin feature/10-6-2
# Create PR for review
```

## Definition of Done
- [ ] All acceptance criteria met
- [ ] Code review approved
- [ ] All tests passing (>90% coverage)
- [ ] Metrics validated against benchmarks
- [ ] Report generation working
- [ ] Documentation complete
- [ ] Branch merged to main

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-03 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-09-03 | 1.1 | Enhanced with full Dev Notes and validation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes List
_TBD_

### File List
_TBD_

## QA Results
_TBD_