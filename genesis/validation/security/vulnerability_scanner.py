"""Vulnerability scanning for dependencies and containers."""

import json
import subprocess
import time
from pathlib import Path
from typing import Any

import structlog

from genesis.validation.base import Validator

logger = structlog.get_logger(__name__)


class VulnerabilityScanner(Validator):
    """Scans dependencies for known vulnerabilities with caching support."""

    SEVERITY_THRESHOLDS = {
        "critical": 0,  # No critical vulnerabilities allowed
        "high": 3,      # Max 3 high severity
        "medium": 10,   # Max 10 medium severity
        "low": None     # No limit on low severity
    }

    # Cache configuration
    CACHE_DIR = Path(".genesis/.validation_cache")
    CACHE_EXPIRY_HOURS = 4  # Cache vulnerability scans for 4 hours

    def __init__(self):
        """Initialize vulnerability scanner with caching."""
        super().__init__(
            validator_id="SEC-002",
            name="Vulnerability Scanner",
            description="Scans dependencies and containers for known vulnerabilities"
        )
        self.tools_available = self._check_available_tools()
        self.vulnerability_db_updated = False
        self.is_critical = True
        self.timeout_seconds = 180
        self._setup_cache()

    def _check_available_tools(self) -> dict[str, bool]:
        """Check which security tools are available.
        
        Returns:
            Dictionary of tool availability
        """
        tools = {
            "safety": self._check_tool("safety", "--version"),
            "bandit": self._check_tool("bandit", "--version"),
            "pip-audit": self._check_tool("pip-audit", "--version"),
            "trivy": self._check_tool("trivy", "--version"),
        }

        logger.info("Security tools availability", tools=tools)
        return tools

    def _check_tool(self, tool_name: str, version_arg: str) -> bool:
        """Check if a tool is available.
        
        Args:
            tool_name: Name of the tool
            version_arg: Argument to check version
            
        Returns:
            True if tool is available
        """
        try:
            result = subprocess.run(
                [tool_name, version_arg],
                capture_output=True,
                text=True,
                timeout=5,
            )
            return result.returncode == 0
        except (subprocess.SubprocessError, FileNotFoundError):
            return False

    def _setup_cache(self):
        """Setup cache directory for vulnerability scan results."""
        self.CACHE_DIR.mkdir(parents=True, exist_ok=True)

    def _get_cache_key(self, scan_type: str) -> Path:
        """Get cache file path for a scan type.
        
        Args:
            scan_type: Type of scan (safety, pip-audit, etc.)
            
        Returns:
            Path to cache file
        """
        return self.CACHE_DIR / f"{scan_type}_cache.json"

    def _is_cache_valid(self, cache_file: Path) -> bool:
        """Check if cache file is still valid.
        
        Args:
            cache_file: Path to cache file
            
        Returns:
            True if cache is valid
        """
        if not cache_file.exists():
            return False

        # Check cache age
        cache_age = time.time() - cache_file.stat().st_mtime
        max_age = self.CACHE_EXPIRY_HOURS * 3600

        return cache_age < max_age

    async def _get_cached_result(self, scan_type: str) -> dict[str, Any] | None:
        """Get cached scan result if valid.
        
        Args:
            scan_type: Type of scan
            
        Returns:
            Cached result or None
        """
        cache_file = self._get_cache_key(scan_type)

        if self._is_cache_valid(cache_file):
            try:
                with open(cache_file) as f:
                    logger.info(f"Using cached {scan_type} results")
                    return json.load(f)
            except Exception as e:
                logger.warning(f"Failed to read cache for {scan_type}: {e}")

        return None

    async def _save_to_cache(self, scan_type: str, result: dict[str, Any]):
        """Save scan result to cache.
        
        Args:
            scan_type: Type of scan
            result: Scan result to cache
        """
        cache_file = self._get_cache_key(scan_type)

        try:
            with open(cache_file, 'w') as f:
                json.dump(result, f, indent=2)
            logger.info(f"Cached {scan_type} results")
        except Exception as e:
            logger.warning(f"Failed to cache {scan_type} results: {e}")

    async def validate(self) -> dict[str, Any]:
        """Run comprehensive vulnerability validation.
        
        Returns:
            Validation results with vulnerabilities and recommendations
        """
        logger.info("Starting vulnerability scanning")

        # Update vulnerability databases if needed
        await self._update_vulnerability_db()

        # Run various vulnerability scanners
        safety_results = await self._run_safety_check() if self.tools_available.get("safety") else {}
        pip_audit_results = await self._run_pip_audit() if self.tools_available.get("pip-audit") else {}
        bandit_results = await self._run_bandit_scan() if self.tools_available.get("bandit") else {}
        docker_results = await self._run_trivy_scan() if self.tools_available.get("trivy") else {}
        owasp_results = await self._run_owasp_check()

        # Aggregate vulnerabilities
        all_vulnerabilities = self._aggregate_vulnerabilities(
            safety_results,
            pip_audit_results,
            bandit_results,
            docker_results,
            owasp_results
        )

        # Evaluate against thresholds
        threshold_violations = self._evaluate_thresholds(all_vulnerabilities)

        # Determine pass/fail
        passed = len(threshold_violations) == 0

        return {
            "passed": passed,
            "summary": {
                "total_vulnerabilities": len(all_vulnerabilities),
                "critical": sum(1 for v in all_vulnerabilities if v.get("severity") == "critical"),
                "high": sum(1 for v in all_vulnerabilities if v.get("severity") == "high"),
                "medium": sum(1 for v in all_vulnerabilities if v.get("severity") == "medium"),
                "low": sum(1 for v in all_vulnerabilities if v.get("severity") == "low"),
            },
            "tools_used": [tool for tool, available in self.tools_available.items() if available],
            "vulnerabilities": all_vulnerabilities,
            "threshold_violations": threshold_violations,
            "recommendations": self._generate_recommendations(all_vulnerabilities, threshold_violations),
        }

    async def _update_vulnerability_db(self):
        """Update vulnerability databases for scanners."""
        if self.vulnerability_db_updated:
            return

        logger.info("Updating vulnerability databases")

        # Update Safety database
        if self.tools_available.get("safety"):
            try:
                subprocess.run(
                    ["safety", "check", "--json", "--db"],
                    capture_output=True,
                    timeout=30,
                )
            except Exception as e:
                logger.warning(f"Failed to update Safety database: {e}")

        # Trivy auto-updates its database
        self.vulnerability_db_updated = True

    async def _run_safety_check(self) -> dict[str, Any]:
        """Run Safety to check Python dependencies with caching.
        
        Returns:
            Safety scan results
        """
        # Check cache first
        cached_result = await self._get_cached_result("safety")
        if cached_result:
            return cached_result

        logger.info("Running Safety vulnerability check")

        try:
            # Check all requirements files
            req_files = list(Path("requirements").glob("*.txt"))
            if not req_files:
                req_files = [Path("requirements.txt")] if Path("requirements.txt").exists() else []

            all_vulnerabilities = []

            for req_file in req_files:
                if not req_file.exists():
                    continue

                result = subprocess.run(
                    ["safety", "check", "--json", "-r", str(req_file)],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )

                if result.stdout:
                    try:
                        data = json.loads(result.stdout)
                        vulnerabilities = data.get("vulnerabilities", [])

                        for vuln in vulnerabilities:
                            all_vulnerabilities.append({
                                "tool": "safety",
                                "package": vuln.get("package_name"),
                                "version": vuln.get("analyzed_version"),
                                "vulnerability": vuln.get("vulnerability_id"),
                                "severity": self._map_safety_severity(vuln.get("severity", "")),
                                "description": vuln.get("advisory"),
                                "fix": vuln.get("more_info_url"),
                                "file": str(req_file),
                            })
                    except json.JSONDecodeError:
                        logger.error("Failed to parse Safety output")

            result = {
                "vulnerabilities": all_vulnerabilities,
                "total_vulnerabilities": len(all_vulnerabilities),
            }

            # Cache the result
            await self._save_to_cache("safety", result)
            return result

        except Exception as e:
            logger.error(f"Error running Safety: {e}")
            return {"vulnerabilities": [], "total_vulnerabilities": 0}

    async def _run_pip_audit(self) -> dict[str, Any]:
        """Run pip-audit for dependency vulnerabilities with caching.
        
        Returns:
            pip-audit scan results
        """
        # Check cache first
        cached_result = await self._get_cached_result("pip-audit")
        if cached_result:
            return cached_result

        logger.info("Running pip-audit vulnerability check")

        try:
            result = subprocess.run(
                ["pip-audit", "--format", "json", "--desc"],
                capture_output=True,
                text=True,
                timeout=60,
            )

            vulnerabilities = []

            if result.stdout:
                try:
                    data = json.loads(result.stdout)
                    dependencies = data.get("dependencies", [])

                    for dep in dependencies:
                        for vuln in dep.get("vulns", []):
                            vulnerabilities.append({
                                "tool": "pip-audit",
                                "package": dep.get("name"),
                                "version": dep.get("version"),
                                "vulnerability": vuln.get("id"),
                                "severity": self._map_pip_audit_severity(vuln.get("fix_versions", [])),
                                "description": vuln.get("description"),
                                "fix": f"Upgrade to {vuln.get('fix_versions', ['unknown'])[0]}",
                            })
                except json.JSONDecodeError:
                    logger.error("Failed to parse pip-audit output")

            result = {
                "vulnerabilities": vulnerabilities,
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": sum(1 for v in vulnerabilities if v["severity"] == "critical"),
                "high_count": sum(1 for v in vulnerabilities if v["severity"] == "high"),
                "moderate_count": sum(1 for v in vulnerabilities if v["severity"] == "medium"),
            }

            # Cache the result
            await self._save_to_cache("pip-audit", result)
            return result

        except Exception as e:
            logger.error(f"Error running pip-audit: {e}")
            return {
                "vulnerabilities": [],
                "total_vulnerabilities": 0,
                "critical_count": 0,
                "high_count": 0,
                "moderate_count": 0,
            }

    async def _run_bandit_scan(self) -> dict[str, Any]:
        """Run Bandit for code security issues.
        
        Returns:
            Bandit scan results
        """
        logger.info("Running Bandit security scan")

        try:
            result = subprocess.run(
                ["bandit", "-r", "genesis", "-f", "json", "-ll"],
                capture_output=True,
                text=True,
                timeout=60,
            )

            issues = []

            if result.stdout:
                try:
                    data = json.loads(result.stdout)
                    results = data.get("results", [])

                    for issue in results:
                        issues.append({
                            "tool": "bandit",
                            "file": issue.get("filename"),
                            "line": issue.get("line_number"),
                            "severity": issue.get("issue_severity", "").lower(),
                            "confidence": issue.get("issue_confidence", "").lower(),
                            "cwe": issue.get("issue_cwe", {}).get("id"),
                            "test": issue.get("test_name"),
                            "description": issue.get("issue_text"),
                        })

                    metrics = data.get("metrics", {}).get("_totals", {})

                    return {
                        "issues": issues,
                        "total_issues": len(issues),
                        "high_severity_count": metrics.get("SEVERITY.HIGH", 0),
                        "medium_severity_count": metrics.get("SEVERITY.MEDIUM", 0),
                        "low_severity_count": metrics.get("SEVERITY.LOW", 0),
                    }
                except json.JSONDecodeError:
                    logger.error("Failed to parse Bandit output")

            return {"issues": [], "total_issues": 0}

        except Exception as e:
            logger.error(f"Error running Bandit: {e}")
            return {"issues": [], "total_issues": 0}

    async def _run_trivy_scan(self) -> dict[str, Any]:
        """Run Trivy for Docker image vulnerabilities.
        
        Returns:
            Trivy scan results
        """
        logger.info("Running Trivy container scan")

        try:
            # Check if Dockerfile exists
            dockerfile_paths = [
                Path("Dockerfile"),
                Path("docker/Dockerfile"),
            ]

            vulnerabilities = []

            for dockerfile in dockerfile_paths:
                if not dockerfile.exists():
                    continue

                # Build image name from context
                image_name = "genesis:security-scan"

                # Try to scan the image
                result = subprocess.run(
                    ["trivy", "image", "--format", "json", "--severity", "CRITICAL,HIGH,MEDIUM", image_name],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )

                if result.returncode == 0 and result.stdout:
                    try:
                        data = json.loads(result.stdout)
                        results = data.get("Results", [])

                        for result_item in results:
                            for vuln in result_item.get("Vulnerabilities", []):
                                vulnerabilities.append({
                                    "tool": "trivy",
                                    "target": result_item.get("Target"),
                                    "type": result_item.get("Type"),
                                    "package": vuln.get("PkgName"),
                                    "version": vuln.get("InstalledVersion"),
                                    "vulnerability": vuln.get("VulnerabilityID"),
                                    "severity": vuln.get("Severity", "").lower(),
                                    "description": vuln.get("Title"),
                                    "fix": vuln.get("FixedVersion", "No fix available"),
                                })
                    except json.JSONDecodeError:
                        logger.error("Failed to parse Trivy output")

            return {
                "vulnerabilities": vulnerabilities,
                "total_vulnerabilities": len(vulnerabilities),
            }

        except Exception as e:
            logger.error(f"Error running Trivy: {e}")
            return {"vulnerabilities": [], "total_vulnerabilities": 0}

    async def _run_owasp_check(self) -> dict[str, Any]:
        """Run OWASP dependency check.
        
        Returns:
            OWASP scan results
        """
        # OWASP dependency check requires Java and is complex to set up
        # We'll check for common OWASP Top 10 patterns in code

        logger.info("Checking for OWASP Top 10 patterns")

        owasp_patterns = {
            "sql_injection": r"(SELECT|INSERT|UPDATE|DELETE).*\+.*%(.*?)\%",
            "xss": r"innerHTML\s*=|document\.write\(",
            "insecure_deserialization": r"pickle\.loads?\(|yaml\.load\(|eval\(",
            "xxe": r"etree\.parse\(.*resolve_entities\s*=\s*True",
            "broken_auth": r"session\[.+\]\s*=\s*request\.",
            "sensitive_exposure": r"logging\.(debug|info)\(.*password|.*token|.*secret",
            "broken_access": r"@app\.route.*methods\s*=\s*\[.*POST.*\](?!.*@requires_auth)",
            "security_misconfiguration": r"DEBUG\s*=\s*True|app\.debug\s*=\s*True",
            "insecure_components": r"requirements.*==\s*(0\.|1\.0|1\.1)",  # Very old versions
            "insufficient_logging": r"except.*:.*pass",
        }

        vulnerabilities = []

        for py_file in Path("genesis").rglob("*.py"):
            try:
                content = py_file.read_text(encoding="utf-8")

                for pattern_name, pattern in owasp_patterns.items():
                    import re
                    if re.search(pattern, content, re.IGNORECASE):
                        vulnerabilities.append({
                            "tool": "owasp-patterns",
                            "file": str(py_file),
                            "type": pattern_name,
                            "severity": "high" if pattern_name in ["sql_injection", "xxe", "insecure_deserialization"] else "medium",
                            "description": f"Potential {pattern_name.replace('_', ' ')} vulnerability pattern detected",
                        })

            except Exception as e:
                logger.error(f"Error checking OWASP patterns in {py_file}: {e}")

        return {
            "vulnerabilities": vulnerabilities,
            "total_vulnerabilities": len(vulnerabilities),
        }

    def _aggregate_vulnerabilities(self, *results) -> list[dict[str, Any]]:
        """Aggregate vulnerabilities from all scanners.
        
        Args:
            *results: Variable number of scan results
            
        Returns:
            Aggregated list of vulnerabilities
        """
        all_vulnerabilities = []

        for result in results:
            if isinstance(result, dict):
                vulns = result.get("vulnerabilities", [])
                if vulns:
                    all_vulnerabilities.extend(vulns)

                issues = result.get("issues", [])
                if issues:
                    all_vulnerabilities.extend(issues)

        # Sort by severity
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        all_vulnerabilities.sort(
            key=lambda x: severity_order.get(x.get("severity", "low"), 4)
        )

        return all_vulnerabilities

    def _evaluate_thresholds(self, vulnerabilities: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Evaluate vulnerabilities against thresholds.
        
        Args:
            vulnerabilities: List of vulnerabilities
            
        Returns:
            List of threshold violations
        """
        violations = []

        # Count by severity
        severity_counts = {
            "critical": sum(1 for v in vulnerabilities if v.get("severity") == "critical"),
            "high": sum(1 for v in vulnerabilities if v.get("severity") == "high"),
            "medium": sum(1 for v in vulnerabilities if v.get("severity") == "medium"),
            "low": sum(1 for v in vulnerabilities if v.get("severity") == "low"),
        }

        # Check against thresholds
        for severity, threshold in self.SEVERITY_THRESHOLDS.items():
            if threshold is not None and severity_counts[severity] > threshold:
                violations.append({
                    "severity": severity,
                    "count": severity_counts[severity],
                    "threshold": threshold,
                    "exceeded_by": severity_counts[severity] - threshold,
                })

        return violations

    def _map_safety_severity(self, safety_severity: str) -> str:
        """Map Safety severity to standard severity.
        
        Args:
            safety_severity: Safety severity string
            
        Returns:
            Standard severity level
        """
        mapping = {
            "critical": "critical",
            "high": "high",
            "medium": "medium",
            "moderate": "medium",
            "low": "low",
        }
        return mapping.get(safety_severity.lower(), "medium")

    def _map_pip_audit_severity(self, fix_versions: list[str]) -> str:
        """Map pip-audit fix urgency to severity.
        
        Args:
            fix_versions: List of fix versions
            
        Returns:
            Severity level
        """
        # If no fix available, it's critical
        if not fix_versions:
            return "critical"
        # Otherwise base on context
        return "high"

    def _generate_recommendations(
        self,
        vulnerabilities: list[dict[str, Any]],
        threshold_violations: list[dict[str, Any]]
    ) -> list[str]:
        """Generate recommendations based on findings.
        
        Args:
            vulnerabilities: List of vulnerabilities
            threshold_violations: List of threshold violations
            
        Returns:
            List of recommendations
        """
        recommendations = []

        # Threshold violations
        if threshold_violations:
            for violation in threshold_violations:
                recommendations.append(
                    f"Reduce {violation['severity']} vulnerabilities by {violation['exceeded_by']} "
                    f"(current: {violation['count']}, threshold: {violation['threshold']})"
                )

        # Tool-specific recommendations
        safety_vulns = [v for v in vulnerabilities if v.get("tool") == "safety"]
        if safety_vulns:
            packages = set(v.get("package") for v in safety_vulns)
            recommendations.append(f"Update vulnerable packages: {', '.join(packages)}")

        bandit_issues = [v for v in vulnerabilities if v.get("tool") == "bandit"]
        if bandit_issues:
            high_confidence = [v for v in bandit_issues if v.get("confidence") == "high"]
            if high_confidence:
                recommendations.append(f"Fix {len(high_confidence)} high-confidence security issues in code")

        trivy_vulns = [v for v in vulnerabilities if v.get("tool") == "trivy"]
        if trivy_vulns:
            recommendations.append("Update base images and dependencies in Docker containers")

        owasp_vulns = [v for v in vulnerabilities if v.get("tool") == "owasp-patterns"]
        if owasp_vulns:
            patterns = set(v.get("type") for v in owasp_vulns)
            recommendations.append(f"Review OWASP patterns: {', '.join(patterns)}")

        # General recommendations
        if not self.tools_available.get("safety"):
            recommendations.append("Install Safety for Python dependency scanning: pip install safety")

        if not self.tools_available.get("trivy"):
            recommendations.append("Install Trivy for container scanning")

        if not vulnerabilities:
            recommendations.append("No vulnerabilities detected - maintain security updates")

        return recommendations
